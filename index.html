<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100%; display: block }
		</style>
	</head>
	<body>
		<script src="js/math.js/math.min.js"></script>
		<script src="js/three.js/build/three.min.js"></script>
		<script src="js/OrbitControl.js"></script>
		<script src="js/Physijs/physi.js"></script>
		<script src="js/stats.min.js"></script>
		<script>

		// TODO:
		//	(1) palla con fisica (gravit√† con three js)
		//	(2) traiettoria robot che segue palla
		//	- textures - luci - mano - gioco - ambientazione

			'use strict';

			Physijs.scripts.worker = 'js/Physijs/physijs_worker.js';
			Physijs.scripts.ammo = '../ammo.js';

			var scene, camera, renderer, controls;
			var init, animate;

			var parser;
			var stats;

			var ball;

			//var M = {}; //new THREE.Matrix4();
			var q = {}, dh, n_joints, Txz, J;

			var ground, ground_material, ground_geometry, ballGeometry, ballMaterial;
			var joints = {};
			var geometries = {};
			var materials = {};
			var length = {};

			//var arrowHelperX = {};
			//var arrowHelperY = {};
			//var arrowHelperZ = {};
			//var dirX = {};
			//var dirY = {};
			//var dirZ = {};
			//var origin =  {};
			//var arrlength = 100;
			//var hexX = 0xff0000;
			//var hexY = 0x00ff00;
			//var hexZ = 0x0000ff;
			//var headLength = 15;
			//var widthLength = 15;

			var rd = [-1000, -1000,0];
			var deltaTDef = [0.0000001, 0.0000001, 0.0000001, 0.0000001], deltaT;
			var maxDisp = 300;
			var minDisp = 1;

			var ballInitPosition = [0, 100, 10000];
			var shootArrow, forceBar;
			var shootArrowXAngle = 0;
			var shootArrowYAngle = 0;
			var ballTotalForce = 50000;
			var ballForce = new THREE.Vector3(0,0,-ballTotalForce);
			var percForce = 1.0;



			//animate();

			init = function () {
					// RENDERER
					renderer = new THREE.WebGLRenderer({ antialias: true });
					renderer.setSize( window.innerWidth, window.innerHeight);
					renderer.shadowMap.enabled = true;
					renderer.shadowMapSoft = true

					// SCENE
					scene = new Physijs.Scene;
					// GRAVITY
					scene.setGravity(new THREE.Vector3( 0, -1000, 0 ));
					scene.addEventListener(
						'update',
						function() {
							// Simulate physics
							scene.simulate();

							stats.update();
						}
					)

					// CAMERA
			    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 20000 );
			    //camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2,  window.innerHeight / 2, window.innerHeight / -2, 1, 20000 );
			    //camera.position.z = ballInitPosition[2];
			    camera.position.z = ballInitPosition[2] + 1000;
			    //camera.position.x = 1000;
			    camera.position.y = 700;
					//camera.lookAt(new THREE.Vector3(ballInitPosition[0], ballInitPosition[1], ballInitPosition[2]));
					camera.lookAt(new THREE.Vector3(0,0,0));

					// MATHJS PARSER
				 	parser = math.parser();


					parser.eval(
						`q = [pi/2, 0, 0, 0]`//-pi/2, -0.7853981633974488, -0.7853981633974488]`
					);
					parser.eval(
						`l = [1500, 0, 1500, 300]`
					)
					parser.eval(
						`dh(q1, q2, q3, q4) =
						[    0, l[1], 0, q1;
						 -pi/2, l[2], 0, q2;
						     0, l[3], 0, q3;
					       0, l[4], 0, q4]`
					);
					 parser.eval(
						 `Txz(al, a, d, th) =
						 [         cos(th),        -sin(th),        0,          a;
						   cos(al)*sin(th), cos(al)*cos(th), -sin(al), -d*sin(al);
						   sin(al)*sin(th), sin(al)*cos(th),  cos(al),  d*cos(al);
						                 0,               0,        0,          1]`
					 );
					 parser.eval(
						 `J(q1, q2, q3, q4) =
						 [ l[4]*sin(q1 + q2)*sin(q3)*sin(q4) - l[1]*sin(q1) - l[3]*sin(q1 + q2)*cos(q3) - l[4]*sin(q1 + q2)*cos(q3)*cos(q4) - l[2]*sin(q1 + q2), -sin(q1 + q2)*(l[2] + l[4]*cos(q3 + q4) + l[3]*cos(q3)), -cos(q1 + q2)*(l[4]*sin(q3 + q4) + l[3]*sin(q3)), -l[4]*cos(q1 + q2)*sin(q3 + q4);
					 	   l[2]*cos(q1 + q2) + l[1]*cos(q1) + l[3]*cos(q1 + q2)*cos(q3) + l[4]*cos(q1 + q2)*cos(q3)*cos(q4) - l[4]*cos(q1 + q2)*sin(q3)*sin(q4),  cos(q1 + q2)*(l[2] + l[4]*cos(q3 + q4) + l[3]*cos(q3)), -sin(q1 + q2)*(l[4]*sin(q3 + q4) + l[3]*sin(q3)), -l[4]*sin(q1 + q2)*sin(q3 + q4);
				 		    	                                                                                                                      					0,                                               			   0,               - l[4]*cos(q3 + q4) - l[3]*cos(q3),              -l[4]*cos(q3 + q4)]`
		 			);
					 parser.eval(
						 `f(q1, q2, q3, q4) =
						 [l[2]*cos(q1 + q2) + l[1]*cos(q1) + l[3]*cos(q1 + q2)*cos(q3) + l[4]*cos(q1 + q2)*cos(q3)*cos(q4) - l[4]*cos(q1 + q2)*sin(q3)*sin(q4),
 						  l[2]*sin(q1 + q2) + l[1]*sin(q1) + l[3]*sin(q1 + q2)*cos(q3) + l[4]*sin(q1 + q2)*cos(q3)*cos(q4) - l[4]*sin(q1 + q2)*sin(q3)*sin(q4),
                                                                                             										- l[4]*sin(q3 + q4) - l[3]*sin(q3)]`
					 );

					var dhf = parser.get('dh');
					Txz = parser.get('Txz');
					J  = parser.get('J');

					dh = dhf(0, 0, 0, 0).toArray();
					n_joints = dh.length;
					console.log('N joints:' + n_joints);

					//TextureLoader
						loader = new THREE.TextureLoader();
					// Initialize q vector to initial configuration
					for (var i=0; i<n_joints; i++)
						q[i] = 0;

					//var robot_arm = new THREE.Group();

					// Create the robot arm according to the DH table
					var T = new THREE.Matrix4();
					for (var i=0; i<n_joints; i++) {
						length[i] = dh[i][1];

						if (i == n_joints-1) {
							geometries[i] = new THREE.CylinderGeometry( length[i], length[i], 50, 16 );
						} else {
							geometries[i] = new THREE.CylinderGeometry( 50, 30, length[i], 16 );
						}
						materials[i] = new Physijs.createMaterial(
														new THREE.MeshNormalMaterial(),
														1, // friction
														1  // restitution
													);

						//joints[i] = new Physijs.CylinderMesh( geometries[i], materials[i],0);
						joints[i] = new Physijs.CylinderMesh( geometries[i], materials[i], 0);
						scene.add( joints[i] );

						joints[i].addEventListener('collision', (function(object) {
							var n = i;
							return function() {console.log('joint' + n + ' collision')};
						})());

					}

					//scene.add( robot_arm );

					// BALL
					ballGeometry = new THREE.SphereGeometry( 70, 32, 32 );
					ballMaterial = new Physijs.createMaterial(
													new THREE.MeshNormalMaterial(),
													1, // friction
													1  // restitution
												);
					ball = new Physijs.SphereMesh(
						ballGeometry,
						ballMaterial,
						10 // mass
					);

					ball.translateZ(ballInitPosition[2]);
					ball.translateY(ballInitPosition[1]);

					//ball.setCcdMotionThreshold(0.1);
					//ball.setCcdSweptSphereRadius(25);

					scene.add(ball);

					//GROUND
					var loader= new THREE.TextureLoader();
				  ground_material = Physijs.createMaterial(
						new THREE.MeshLambertMaterial({ map: loader.load( 'images/grass.jpg' ) }),
						.8, // high friction
						.3 // low restitution
					);
					ground_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
					ground_material.map.repeat.set( 3, 3 );

					ground_geometry = new THREE.PlaneGeometry(10000, 100000, 100);
					ground = new Physijs.PlaneMesh(	ground_geometry,	ground_material,	0 );
					ground.rotateX(-math.pi/2);
					ground.receiveShadow = true;
					//ground.position.y=-1000;
					scene.add(ground);

					//luce NECESSARIA per la texture
					var light = new THREE.DirectionalLight( 0xFFFFFF );
					light.position.set( 20, 40, -15 );
					light.target.position.copy( scene.position );
					light.castShadow = true;
					light.shadow.camera.left = -60;
					light.shadow.camera.top = -60;
					light.shadow.camera.right = 60;
					light.shadow.camera.bottom = 60;
					light.shadow.camera.near = 20;
					light.shadow.camera.far = 200;
					light.shadow.bias = -.0001;
					light.shadow.mapSize.width = light.shadow.mapSize.height = 2048;
					//light.shadowDarkness = .7;
					scene.add( light );

					// SHOOT ARROW
					var arrowShape = new THREE.Shape();
					arrowShape.moveTo(  -50, 0 );
					arrowShape.lineTo(  -100, 150 );
					arrowShape.lineTo( -200, 150 );
					arrowShape.lineTo(  0, 300 );
					arrowShape.lineTo(  200, 150 );
					arrowShape.lineTo(  100, 150 );
					arrowShape.lineTo(  50, 0 );
					arrowShape.lineTo(  -50, 0 );
					var arrowGeometry = new THREE.ShapeGeometry(arrowShape);
					shootArrow = new THREE.Mesh(arrowGeometry, new THREE.MeshNormalMaterial( { } ));

					shootArrow.translateZ(ballInitPosition[2] - 50);
					shootArrow.rotateX(-math.pi/2);
					shootArrow.rotateY(0);

          scene.add(shootArrow);

					// FORCE BAR
					var barShape = new THREE.Shape();
					barShape.moveTo(0, 0);
					barShape.lineTo(0, 200);
					barShape.lineTo(20, 200);
					barShape.lineTo(20, 0);
					barShape.lineTo(0, 0);
					var barGeometry = new THREE.ShapeGeometry(barShape);
					forceBar = new THREE.Mesh(barGeometry, new THREE.MeshNormalMaterial());
					forceBar.position.x = 200;
					forceBar.position.z = ballInitPosition[2];

					scene.add(forceBar);

					// To move the scene according to mouse events
					controls = new THREE.OrbitControls( camera, renderer.domElement );
					//controls.enabled = false;

			    document.body.appendChild( renderer.domElement );

					stats = new Stats();
					document.body.appendChild( stats.dom );

					// Trigger for user events
					initEventHandling();

					requestAnimationFrame( animate );

					scene.simulate();
			}

			function initEventHandling() {
					var handleKeyPress = function(evt) {
							var shootAngleStep = math.pi/48, shootForceStep = 0.1;
							var shootMaxXAngle = math.pi/2, shootMinXAngle = 0;
							var shootMaxYAngle = math.pi/6, shootMinYAngle = -math.pi/3;
							if (evt.keyCode == 32) { // 32 = spacebar
								ball.applyCentralImpulse(ballForce); // Apply force to the ball
							} else if (evt.keyCode == 65) { // 37 = left arrow
								shootArrowYAngle += (shootArrowYAngle + shootAngleStep < shootMaxYAngle) ? shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 87) { // 38 = up arrow
								shootArrowXAngle += (shootArrowXAngle + shootAngleStep < shootMaxXAngle) ? shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 68) { // 39 = right arrow
								shootArrowYAngle += (shootArrowYAngle - shootAngleStep > shootMinYAngle) ? - shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 83) { // 40 = down arrow
								shootArrowXAngle += (shootArrowXAngle - shootAngleStep > shootMinXAngle) ? - shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 107) { // 107 = +
								percForce += (percForce < 1) ? shootForceStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 109) { // 109 = -
								percForce -= (percForce > 0.01) ? shootForceStep : 0;
								recomputeShootForces();
							}
					};

					//document.addEventListener('keypress', handleKeyPress);
					document.addEventListener('keydown', handleKeyPress);
					//document.addEventListener('keydown', function(evt) {console.log(evt.keyCode)});

					var handleCollision = function(obj) {
						console.log('ball collision');
					};

					ball.addEventListener('collision', handleCollision);

				}


			animate = function () {
			    requestAnimationFrame( animate );

			    renderer.render( scene, camera );

					controls.update();

					updateJoints();

			}

			function recomputeShootForces() {
					// rotate the shootArrow
					shootArrow.rotation.set(-math.pi/2,0,0,'XYZ');
					shootArrow.rotateZ(shootArrowYAngle);
					shootArrow.rotateX(shootArrowXAngle);

					// scale force bar
					forceBar.scale.setY(percForce);

					// compute the forces
					ballForce.setX(math.cos(shootArrowXAngle) * math.sin(-shootArrowYAngle) * ballTotalForce * percForce);
					ballForce.setY(math.sin(shootArrowXAngle) * ballTotalForce * percForce);
					ballForce.setZ(-1 * math.cos(shootArrowXAngle) * math.cos(shootArrowYAngle) * ballTotalForce * percForce);
			}

			function computeJoints() {
					var jointVelMax = 0.02;
					// target position as ball position
					if (ball.position.z > 4000) {
						parser.eval(
							`rd = [` + ball.position.x + ',' + ball.position.y + ',' + 0 + `]`
						);
						deltaT = deltaTDef;
					} else if (ball.position.z < -1000) {
						parser.eval(
							//`rd = [` + camera.position.x + ',' + camera.position.y + ',' + 0 + `]`
							`rd = [0, 2000, 0]`
						);
						deltaT = deltaTDef;
					} else if (ball.position.z > 1000) {
						parser.eval(
							`rd = [` + ball.position.x + ',' + ball.position.y + ',' + (-2000) + `]`
						);
						deltaT = deltaTDef;
						//parser.eval(
						//	`rd = [` + ball.position.x + ',' + ball.position.y + ',' + 0 + `]`
						//);
					} else {
						//parser.eval(
						//	`rd = [` + ball.position.x + ',' + ball.position.y + ',' + 0 + `]`
						//);
						parser.eval(
							`rd = [` + ball.position.x + ',' + ball.position.y + ',' + ball.position.z + `]`
						);
						//for (var i=0; i<n_joints; i++) {
						//	deltaT[i] *= 1.02;
						//}
					}
					//parser.eval(
					//	`rd = [0, 2000, 0]`
					//);
					// UPDATE q vector with new angle values
					// Cartesian error
					parser.eval(`cerr = (rd - f(q[1], q[2], q[3], q[4]))`)
					// Take gradient error
					parser.eval(`qerr = transpose(J(q[1], q[2], q[3], q[4])) * cerr`);

					//var cerr = parser.get('cerr');
					//var qerr = parser.get('qerr');

					// Limit joint displacements
					//for (var i=0; i<n_joints; i++) {
					//	if (math.abs(qerr.get([i])) > maxDisp) {
					//		deltaT[i] *= 1.01;
					//	} else if (math.abs(qerr.get([i])) < minDisp){
					//		deltaT[i] /= 1.01;
					//	}
					//}

					//parser.eval(`vel = [`+ deltaT.toString() +`] .* qerr`);
					parser.set(`vel`, []);
					for (var i=1; i<=n_joints; i++) {
						parser.eval(`vel[`+ i +`] = min(abs(`+ deltaT[i-1].toString() +` * qerr[`+ i +`]), `+ jointVelMax +`) * sign(qerr[`+ i +`])`);
					}

					//console.log(parser.get(`vel`));

					parser.eval(`q = q + vel`);
					q = parser.get('q');
					if (q.get([0]) > math.pi)
						q.set([0], math.pi);
					else if (q.get([0]) < 0)
						q.set([0], 0);
					console.log(q.get([0]));
					//console.log('q    ' + parser.eval(`q`).toString());
					//console.log('f    ' + parser.eval(`f(q[1], q[2], q[3], q[4])`).toString());
					//console.log('cerr ' + cerr.toString());
					//console.log('qerr ' + qerr.toString());
					//console.log('delT ' + deltaT.toString());
					//console.log('d*qe ' + parser.eval(`[`+ deltaT.toString() +`] .* qerr`));
					//console.log('q    ' + q.toString());
					//console.log(parser.eval(`J(q[1], q[2], q[3], q[4])`));
			}

			function updateJoints() {

				computeJoints();

				var M = new THREE.Matrix4();
				for (var i=0; i<n_joints; i++) {

					var Inv = new THREE.Matrix4().getInverse(joints[i].matrix);

					// Bring joint in the correct 0
					var S = new THREE.Matrix4();
					S.multiply(new THREE.Matrix4().makeTranslation(length[i]/2, 0, 0));
					S.multiply(new THREE.Matrix4().makeRotationZ(-math.pi/2));
					if (i == n_joints-1)
						S.multiply(new THREE.Matrix4().makeRotationZ(math.pi/2));

					//if (i>0)
					//	M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tx(dh[i-1][0], dh[i-1][1])).toArray())));//dh[i][2])).toArray())));
					//M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tz(q.get([i]), dh[i][2])).toArray())));//dh[i][2])).toArray())));

					if (i>0)
						M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Txz(dh[i-1][0], dh[i-1][1], dh[i][2], q.get([i])).toArray()))));
					else
						M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Txz(0, 0, dh[i][2], q.get([i])).toArray()))));

					var T = ((new THREE.Matrix4().multiply(M)).multiply(S)).multiply(Inv);
					//console.log(T.elements);
					//console.log(q.get([i]));



					joints[i].applyMatrix(T);
					joints[i].__dirtyPosition = true;
					joints[i].__dirtyRotation = true;
					//console.log(joints[i]);
					//console.log(arrowHelperX[i]);

				}
			}
			window.onload = init;

		</script>
	</body>
</html>
