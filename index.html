<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/math.js/math.min.js"></script>
		<script src="js/three.js/build/three.min.js"></script>
		<script src="js/OrbitControl.js"></script>
		<script src="js/Physijs/physi.js"></script>
		<script>

		// TODO:
		//	(1) palla con fisica (gravit√† con three js)
		//	(2) traiettoria robot che segue palla
		//	- textures - luci - mano - gioco - ambientazione

			'use strict';

			Physijs.scripts.worker = 'js/Physijs/physijs_worker.js';
			Physijs.scripts.ammo = '../ammo.js';

			var scene, camera, renderer, controls;
			var geometry, material, mesh;

			var parser;

			var ball;

			var tick = 0;

			//var M = {}; //new THREE.Matrix4();
			var q = {};
			var dh;
			var n_joints;
			var Tx, Tz;
			var J;

			var joints = {};
			var geometries = {};
			var materials = {};
			var frames = {};
			var length = {};

			var arrowHelperX = {};
			var arrowHelperY = {};
			var arrowHelperZ = {};
			var dirX = {};
			var dirY = {};
			var dirZ = {};
			var origin =  {};
			var arrlength = 100;
			var hexX = 0xff0000;
			var hexY = 0x00ff00;
			var hexZ = 0x0000ff;
			var headLength = 15;
			var widthLength = 15;

			var rd = [-1000, -1000,0];
			var deltaT = [0.0000001, 0.0000001, 0.0000001, 0.0000001] ;
			var q;
			var maxDisp = 300;
			var minDisp = 1;

			init();
			animate();

			function init() {
					scene = new Physijs.Scene;

					 parser = math.parser();

					parser.eval(
						`rd = [` + rd.toString() + `]`
					);
					parser.eval(
						`q = [0.01, 0, 0,0]`//-pi/2, -0.7853981633974488, -0.7853981633974488]`
					);
					parser.eval(
						`dh(q1, q2, q3, q4) =
						[0,   500, 0, q1;
						 -pi/2, 0, 0, q2;
						 0, 500, 0, q3;
					   0, 200, 0,  q4]`
					);
					parser.eval(
						`Tz(th, d) =
						[cos(th), -sin(th), 0, 0;
						 sin(th),  cos(th), 0, 0;
					         0,        0, 1, d;
						       0,        0, 0, 1]`
					 );
					 parser.eval(
						 `Tx(al, a) =
						 [1,       0,        0, a;
						  0, cos(al), -sin(al), 0;
							0, sin(al),  cos(al), 0;
							0,       0,        0, 1]`
					 );
					 parser.eval(
						 `J(q1, q2, q3, q4) =
						 [ 200*sin(q1 + q2)*sin(q3)*sin(q4) - 500*sin(q1 + q2)*cos(q3) - 200*sin(q1 + q2)*cos(q3)*cos(q4) - 500*sin(q1), 200*sin(q1 + q2)*sin(q3)*sin(q4) - 200*sin(q1 + q2)*cos(q3)*cos(q4) - 500*sin(q1 + q2)*cos(q3), - 500*cos(q1 + q2)*sin(q3) - 200*cos(q1 + q2)*cos(q3)*sin(q4) - 200*cos(q1 + q2)*cos(q4)*sin(q3), - 200*cos(q1 + q2)*cos(q3)*sin(q4) - 200*cos(q1 + q2)*cos(q4)*sin(q3);
						   500*cos(q1) + 500*cos(q1 + q2)*cos(q3) + 200*cos(q1 + q2)*cos(q3)*cos(q4) - 200*cos(q1 + q2)*sin(q3)*sin(q4), 500*cos(q1 + q2)*cos(q3) + 200*cos(q1 + q2)*cos(q3)*cos(q4) - 200*cos(q1 + q2)*sin(q3)*sin(q4), - 500*sin(q1 + q2)*sin(q3) - 200*sin(q1 + q2)*cos(q3)*sin(q4) - 200*sin(q1 + q2)*cos(q4)*sin(q3), - 200*sin(q1 + q2)*cos(q3)*sin(q4) - 200*sin(q1 + q2)*cos(q4)*sin(q3);
						                                                                                                              0,                                                                                              0,                                                                 - 200*cos(q3 + q4) - 500*cos(q3),                                                     -200*cos(q3 + q4)]`
		 			);
					 parser.eval(
						 `f(q1, q2, q3, q4) =
						 [500*cos(q1) + 500*cos(q1 + q2)*cos(q3) + 200*cos(q1 + q2)*cos(q3)*cos(q4) - 200*cos(q1 + q2)*sin(q3)*sin(q4),
 						  500*sin(q1) + 500*sin(q1 + q2)*cos(q3) + 200*sin(q1 + q2)*cos(q3)*cos(q4) - 200*sin(q1 + q2)*sin(q3)*sin(q4),
                                                                             							- 200*sin(q3 + q4) - 500*sin(q3)]`
					 );

					var dhf = parser.get('dh');
					Tz = parser.get('Tz');
					Tx = parser.get('Tx');
					J = parser.get('J');

					dh = dhf(0, 0, 0, 0).toArray();
					n_joints = dh.length;
					console.log('N joints:' + n_joints);

					var robot_arm = new THREE.Group();

					// Initialize q vector to initial configuration
					for (var i=0; i<n_joints; i++)
						q[i] = 0;

					/*
					 * Frame zero
					 */
					scene.add( new THREE.ArrowHelper( new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( 0, 0, 0 ), 200, hexX, headLength, widthLength ) );
					scene.add( new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 0 ), 200, hexY, headLength, widthLength ) );
					scene.add( new THREE.ArrowHelper( new THREE.Vector3( 0, 0, 1 ), new THREE.Vector3( 0, 0, 0 ), 200, hexZ, headLength, widthLength ) );

					//console.log(M.elements);

					// Create the robot arm according to the DH table
					var T = new THREE.Matrix4();
					for (var i=0; i<n_joints; i++) {
						length[i] = dh[i][1];

						geometries[i] = new THREE.CylinderGeometry( 20, 20, length[i], 16 );
						materials[i] = new THREE.MeshNormalMaterial( {wireframe: true } );

						joints[i] = new THREE.Mesh( geometries[i], materials[i] );

						robot_arm.add( joints[i] );

						/*
						 * Frame origins
						 */
						dirX[i]   = new THREE.Vector3( 1, 0, 0 );
						dirY[i]   = new THREE.Vector3( 0, 1, 0 );
						dirZ[i]   = new THREE.Vector3( 0, 0, 1 );
						origin[i] = new THREE.Vector3( 0, 0, 0 );

						arrowHelperX[i] = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
						arrowHelperY[i] = new THREE.ArrowHelper( dirY[i], origin[i], arrlength, hexY, headLength, widthLength );
						arrowHelperZ[i] = new THREE.ArrowHelper( dirZ[i], origin[i], arrlength, hexZ, headLength, widthLength );
						scene.add( arrowHelperX[i] );
						scene.add( arrowHelperY[i] );
						scene.add( arrowHelperZ[i] );
					}

					scene.add( robot_arm );

					// BALL
					ball = new Physijs.SphereMesh(
						new THREE.SphereGeometry( 50, 32, 32 ),
						new Physijs.createMaterial(
							new THREE.MeshNormalMaterial(),
							1, // friction
							1  // restitution
						),
						10 // mass
					);
					ball.translateZ(4000);

					scene.add(ball);


					// PLANE
					var plane = new Physijs.PlaneMesh(
						new THREE.PlaneGeometry( 400, 400, 32 ),
						new Physijs.createMaterial(
							new THREE.MeshNormalMaterial(),
							1, // friction
							1  // restitution
						),
						0
					);
					plane.translateY(-100);
					plane.rotateX(-math.pi/2);

					scene.add(plane);

					// GRAVITY
					scene.setGravity(new THREE.Vector3( 0, -1000, 0 ));

					// CAMERA
			    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
			    //camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2,  window.innerHeight / 2, window.innerHeight / -2, 1, 10000 );
			    camera.position.z = 5000;

					// RENDERER
			    renderer = new THREE.WebGLRenderer({ antialias: true });
					renderer.setSize( window.innerWidth, window.innerHeight );
					renderer.shadowMap.enabled = true;
					renderer.shadowMapSoft = true

					// To move the scene according to mouse events
					controls = new THREE.OrbitControls( camera, renderer.domElement );

			    document.body.appendChild( renderer.domElement );

					// Trigger for user events
					initEventHandling();
			}

			function initEventHandling() {
					var handleKeyPress = function(evt) {
							if (evt.keyCode == 32) { // 32 = spacebar
								// Apply force to the ball
								ball.applyCentralImpulse(new THREE.Vector3(0, 150, -200));
							}
					};

					document.addEventListener('keypress', handleKeyPress);
			}

			function animate() {
			    requestAnimationFrame( animate );

					// Simulate physics
					scene.simulate();

			    renderer.render( scene, camera );

					update();
			}

			function update() {
					tick++;
					controls.update();
					computeJoints();
					updateJoints();
			}

			function computeJoints() {
					// UPDATE q vector with new angle values
					// Cartesian error
					parser.eval(`cerr = (rd - f(q[1], q[2], q[3], q[4]))`)
					// Take gradient error
					parser.eval(`qerr = transpose(J(q[1], q[2], q[3], q[4])) * cerr`);

					var cerr = parser.get('cerr');
					var qerr = parser.get('qerr');

					// Limit joint displacements
					//for (var i=0; i<n_joints; i++) {
					//	if (math.abs(qerr.get([i])) > maxDisp) {
					//		deltaT[i] *= 1.01;
					//	} else if (math.abs(qerr.get([i])) < minDisp){
					//		deltaT[i] /= 1.01;
					//	}
					//}

					parser.eval(`q = q + [`+ deltaT.toString() +`] .* transpose(qerr)`);
					q = parser.get('q');
					console.log('q    ' + parser.eval(`q`).toString());
					//console.log('rd   ' + parser.get(`rd`).toString());
					console.log('f    ' + parser.eval(`f(q[1], q[2], q[3], q[4])`).toString());
					console.log('cerr ' + cerr.toString());
					console.log('qerr ' + qerr.toString());
					console.log('delT ' + deltaT.toString());
					console.log('d*qe ' + parser.eval(`[`+ deltaT.toString() +`] .* qerr`));
					console.log('q    ' + q.toString());
					console.log(parser.eval(`J(q[1], q[2], q[3], q[4])`));
			}

			function updateJoints() {
				var M = new THREE.Matrix4();
				for (var i=0; i<n_joints; i++) {

					tick ++;

					var Inv = new THREE.Matrix4().getInverse(joints[i].matrix);

					// Bring joint in the correct 0
					var S = new THREE.Matrix4();
					S.multiply(new THREE.Matrix4().makeTranslation(length[i]/2, 0, 0));
					S.multiply(new THREE.Matrix4().makeRotationZ(-math.pi/2));
					if (i>0)
						M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tx(dh[i-1][0], dh[i-1][1])).toArray())));//dh[i][2])).toArray())));
					M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tz(q.get([i]), dh[i][2])).toArray())));//dh[i][2])).toArray())));
					console.log(q.get([i]));
					var T = ((new THREE.Matrix4().multiply(M)).multiply(S)).multiply(Inv);




					joints[i].applyMatrix(T);
					//console.log(arrowHelperX[i]);
					/*
					* Frame origins
					*/
					//dirX[i].transformDirection(M[i]);
					//dirY[i].transformDirection(M[i]);
					//dirZ[i].transformDirection(M[i]);
					//origin[i].setFromMatrixColumn(M[i], 3);
					//var SX = new THREE.Matrix4();
					//var SY = new THREE.Matrix4();
					//var SZ = new THREE.Matrix4();
					//S.multiply(new THREE.Matrix4().makeTranslation(length[i]/2, 0, 0));
					//S.multiply(new THREE.Matrix4().makeRotationZ(-math.pi/2));

					//var Mx = new THREE.Matrix4().copy(arrowHelperX[i].matrix);
					//var My = new THREE.Matrix4().copy(arrowHelperY[i].matrix);
					//var Mz = new THREE.Matrix4().copy(arrowHelperZ[i].matrix);

					//arrowHelperX[i].applyMatrix(new THREE.Matrix4().extractRotation(Mx.transpose())); //new THREE.Matrix4().getInverse(arrowHelperX[i].matrix);
					//arrowHelperY[i].applyMatrix(new THREE.Matrix4().extractRotation(My.transpose())); //new THREE.Matrix4().getInverse(arrowHelperY[i].matrix);
					//arrowHelperZ[i].applyMatrix(new THREE.Matrix4().extractRotation(Mz.transpose())); //new THREE.Matrix4().getInverse(arrowHelperZ[i].matrix);
					//var TX = (new THREE.Matrix4().multiply(M)).multiply(InvX);
					//var TY = (new THREE.Matrix4().multiply(M)).multiply(InvY);
					//var TZ = (new THREE.Matrix4().multiply(M)).multiply(InvZ);
					//console.log(InvX.elements);
					//console.log(Mx.elements);
					//console.log(arrowHelperX[i].matrix.elements);

					//console.log(arrowHelperY[i].matrix.elements);
					//console.log(arrowHelperZ[i].matrix.elements);
					//arrowHelperX[i].setDirection(new THREE.Vector3(1, 0, 0));
					//arrowHelperX[i].applyMatrix(InvX);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//arrowHelperX[i].applyMatrix(M);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//arrowHelperY[i].applyMatrix(M);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//arrowHelperZ[i].applyMatrix(M);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//console.log(i);
					//console.log(M.elements);
					//console.log(arrowHelperX[i].rotation);

					//arrowHelperY[i].applyMatrix(TY);// = new THREE.ArrowHelper( dirY[i], origin[i], arrlength, hexY, headLength, widthLength );
					//arrowHelperZ[i].applyMatrix(TZ);// = new THREE.ArrowHelper( dirZ[i], origin[i], arrlength, hexZ, headLength, widthLength );

				}
			}

		</script>
	</body>
</html>
