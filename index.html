<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100%; display: block }
		</style>
	</head>
	<body>
		 <script src="js/math.js/math.min.js"></script>
		<script src="js/three.js/build/three.min.js"></script>
		<script src="js/OrbitControl.js"></script>
		<script src="js/Physijs/physi.js"></script>
		<script src="js/stats.min.js"></script>
		<script>

		// TODO:
		//	(1) palla con fisica (gravit√† con three js)
		//	(2) traiettoria robot che segue palla
		//	- textures - luci - mano - gioco - ambientazione

			'use strict';

			Physijs.scripts.worker = 'js/Physijs/physijs_worker.js';
			Physijs.scripts.ammo = '../ammo.js';
			var loader;
			var scene, camera, renderer, controls;
			var geometry, material, mesh;
			var light;
			var parser;
			var stats;

			var ball;

			var tick = 0;

			//var M = {}; //new THREE.Matrix4();
			var q = {};
			var dh;
			var n_joints;
			var Tx, Tz;
			var J;

			var joints = {};
			var geometries = {};
			var materials = {};
			var frames = {};
			var length = {};

			var arrowHelperX = {};
			var arrowHelperY = {};
			var arrowHelperZ = {};
			var dirX = {};
			var dirY = {};
			var dirZ = {};
			var origin =  {};
			var arrlength = 100;
			var hexX = 0xff0000;
			var hexY = 0x00ff00;
			var hexZ = 0x0000ff;
			var headLength = 15;
			var widthLength = 15;

			var rd = [-1000, -1000,0];
			var deltaT = [0.0000001, 0.0000001, 0.0000001, 0.0000001] ;
			var q;
			var maxDisp = 300;
			var minDisp = 1;

			var ballInitPosition = [0, 100, 10000];
			var shootArrow;
			var shootArrowXAngle = 0;
			var shootArrowYAngle = 0;
			var ballTotalForce = 20000;
			var ballForce = new THREE.Vector3(0,0,-ballTotalForce);


			init();
			animate();

			function init() {
					scene = new Physijs.Scene;

				 	parser = math.parser();


					parser.eval(
						`q = [0.01, 0, 0,0]`//-pi/2, -0.7853981633974488, -0.7853981633974488]`
					);
					parser.eval(
						`dh(q1, q2, q3, q4) =
						[0,   500, 0, q1;
						 -pi/2, 0, 0, q2;
						 0, 500, 0, q3;
					   0, 200, 0,  q4]`
					);
					parser.eval(
						`Tz(th, d) =
						[cos(th), -sin(th), 0, 0;
						 sin(th),  cos(th), 0, 0;
					         0,        0, 1, d;
						       0,        0, 0, 1]`
					 );
					 parser.eval(
						 `Tx(al, a) =
						 [1,       0,        0, a;
						  0, cos(al), -sin(al), 0;
							0, sin(al),  cos(al), 0;
							0,       0,        0, 1]`
					 );
					 parser.eval(
						 `J(q1, q2, q3, q4) =
						 [ 200*sin(q1 + q2)*sin(q3)*sin(q4) - 500*sin(q1 + q2)*cos(q3) - 200*sin(q1 + q2)*cos(q3)*cos(q4) - 500*sin(q1), 200*sin(q1 + q2)*sin(q3)*sin(q4) - 200*sin(q1 + q2)*cos(q3)*cos(q4) - 500*sin(q1 + q2)*cos(q3), - 500*cos(q1 + q2)*sin(q3) - 200*cos(q1 + q2)*cos(q3)*sin(q4) - 200*cos(q1 + q2)*cos(q4)*sin(q3), - 200*cos(q1 + q2)*cos(q3)*sin(q4) - 200*cos(q1 + q2)*cos(q4)*sin(q3);
						   500*cos(q1) + 500*cos(q1 + q2)*cos(q3) + 200*cos(q1 + q2)*cos(q3)*cos(q4) - 200*cos(q1 + q2)*sin(q3)*sin(q4), 500*cos(q1 + q2)*cos(q3) + 200*cos(q1 + q2)*cos(q3)*cos(q4) - 200*cos(q1 + q2)*sin(q3)*sin(q4), - 500*sin(q1 + q2)*sin(q3) - 200*sin(q1 + q2)*cos(q3)*sin(q4) - 200*sin(q1 + q2)*cos(q4)*sin(q3), - 200*sin(q1 + q2)*cos(q3)*sin(q4) - 200*sin(q1 + q2)*cos(q4)*sin(q3);
						                                                                                                              0,                                                                                              0,                                                                 - 200*cos(q3 + q4) - 500*cos(q3),                                                     -200*cos(q3 + q4)]`
		 			);
					 parser.eval(
						 `f(q1, q2, q3, q4) =
						 [500*cos(q1) + 500*cos(q1 + q2)*cos(q3) + 200*cos(q1 + q2)*cos(q3)*cos(q4) - 200*cos(q1 + q2)*sin(q3)*sin(q4),
 						  500*sin(q1) + 500*sin(q1 + q2)*cos(q3) + 200*sin(q1 + q2)*cos(q3)*cos(q4) - 200*sin(q1 + q2)*sin(q3)*sin(q4),
                                                                             							- 200*sin(q3 + q4) - 500*sin(q3)]`
					 );


					var dhf = parser.get('dh');
					Tz = parser.get('Tz');
					Tx = parser.get('Tx');
					J = parser.get('J');

					dh = dhf(0, 0, 0, 0).toArray();
					n_joints = dh.length;
					console.log('N joints:' + n_joints);

					var robot_arm = new THREE.Group();
					//TextureLoader
						loader = new THREE.TextureLoader();
					// Initialize q vector to initial configuration
					for (var i=0; i<n_joints; i++)
						q[i] = 0;

						//LI
					/*
					 * Frame zero
					 */
					scene.add( new THREE.ArrowHelper( new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( 0, 0, 0 ), 200, hexX, headLength, widthLength ) );
					scene.add( new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 0 ), 200, hexY, headLength, widthLength ) );
					scene.add( new THREE.ArrowHelper( new THREE.Vector3( 0, 0, 1 ), new THREE.Vector3( 0, 0, 0 ), 200, hexZ, headLength, widthLength ) );

					//console.log(M.elements);

					// Create the robot arm according to the DH table
					var T = new THREE.Matrix4();
					for (var i=0; i<n_joints; i++) {
						length[i] = dh[i][1];

						geometries[i] = new THREE.CylinderGeometry( 20, 20, length[i], 16 );
						materials[i] = new THREE.MeshNormalMaterial( );

						joints[i] = new Physijs.CylinderMesh( geometries[i], new Physijs.createMaterial(materials[i],1,1),0);

						robot_arm.add( joints[i] );

						/*
						 * Frame origins
						 */
						dirX[i]   = new THREE.Vector3( 1, 0, 0 );
						dirY[i]   = new THREE.Vector3( 0, 1, 0 );
						dirZ[i]   = new THREE.Vector3( 0, 0, 1 );
						origin[i] = new THREE.Vector3( 0, 0, 0 );

						arrowHelperX[i] = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
						arrowHelperY[i] = new THREE.ArrowHelper( dirY[i], origin[i], arrlength, hexY, headLength, widthLength );
						arrowHelperZ[i] = new THREE.ArrowHelper( dirZ[i], origin[i], arrlength, hexZ, headLength, widthLength );
						scene.add( arrowHelperX[i] );
						scene.add( arrowHelperY[i] );
						scene.add( arrowHelperZ[i] );
					}

					scene.add( robot_arm );

					// BALL
					ball = new Physijs.SphereMesh(
						new THREE.SphereGeometry( 150, 32, 32 ),
						new Physijs.createMaterial(
							new THREE.MeshNormalMaterial(),
							1, // friction
							1  // restitution
						),
						10 // mass
					);

					ball.translateZ(ballInitPosition[2]);
					ball.translateY(ballInitPosition[1]);

					scene.add(ball);

					//GROUND
					loader= new THREE.TextureLoader();
				var	ground_material = Physijs.createMaterial(
						new THREE.MeshLambertMaterial({ map: loader.load( 'images/grass.png' ) }),
						.8, // high friction
						.3 // low restitution
					);
					ground_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
					ground_material.map.repeat.set( 3, 3 );

					var ground = new Physijs.BoxMesh(	new THREE.PlaneGeometry(10000, 100000, 100),	ground_material,	0 );
					ground.rotateX(-math.pi/2);
					ground.receiveShadow = true;
					//ground.position.y=-80;
					scene.add(ground);
					//luce NECESSARIA per la texture
					light = new THREE.DirectionalLight( 0xFFFFFF );
					light.position.set( 20, 40, -15 );
					light.target.position.copy( scene.position );
					light.castShadow = true;
					light.shadowCameraLeft = -60;
					light.shadowCameraTop = -60;
					light.shadowCameraRight = 60;
					light.shadowCameraBottom = 60;
					light.shadowCameraNear = 20;
					light.shadowCameraFar = 200;
					light.shadowBias = -.0001
					light.shadowMapWidth = light.shadowMapHeight = 2048;
					light.shadowDarkness = .7;
					scene.add( light );


					// GRAVITY
					scene.setGravity(new THREE.Vector3( 0, -1000, 0 ));
						//	PER COLLIZIONI?
						scene.addEventListener(
							'update',
							function() {
								scene.simulate( undefined, 1 );
													}
						);
					// SHOOT ARROW
					var arrowShape = new THREE.Shape();
					arrowShape.moveTo(  -50, 0 );
					arrowShape.lineTo(  -100, 150 );
					arrowShape.lineTo( -200, 150 );
					arrowShape.lineTo(  0, 300 );
					arrowShape.lineTo(  200, 150 );
					arrowShape.lineTo(  100, 150 );
					arrowShape.lineTo(  50, 0 );
					arrowShape.lineTo(  -100, 0 );
					var arrowGeometry = new THREE.ShapeGeometry(arrowShape);
					shootArrow = new THREE.Mesh(arrowGeometry, new THREE.MeshNormalMaterial( { } ));

					shootArrow.translateZ(ballInitPosition[2] - 50);
					shootArrow.rotateX(-math.pi/2);
					shootArrow.rotateY(0);

          scene.add(shootArrow);

					// CAMERA
			    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 20000 );
			    //camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2,  window.innerHeight / 2, window.innerHeight / -2, 1, 20000 );
			    //camera.position.z = ballInitPosition[2];
			    camera.position.z = ballInitPosition[2] + 1000;
			    //camera.position.x = 1000;
			    camera.position.y = 700;
					//camera.lookAt(new THREE.Vector3(ballInitPosition[0], ballInitPosition[1], ballInitPosition[2]));
					camera.lookAt(new THREE.Vector3(0,0,0));

					// RENDERER
			    renderer = new THREE.WebGLRenderer({ antialias: true });
					renderer.setSize( window.innerWidth, window.innerHeight);
					renderer.shadowMap.enabled = true;
					renderer.shadowMapSoft = true

					// To move the scene according to mouse events
				//	controls = new THREE.OrbitControls( camera, renderer.domElement );
					//controls.enabled = false;

			    document.body.appendChild( renderer.domElement );

					stats = new Stats();
					document.body.appendChild( stats.dom );

					// Trigger for user events
					initEventHandling();
			}

			function initEventHandling() {
					var handleKeyPress = function(evt) {
							var shootAngleStep = math.pi/48;
							var shootMaxXAngle = math.pi/2, shootMinXAngle = 0;
							var shootMaxYAngle = math.pi/6, shootMinYAngle = -math.pi/3;
							if (evt.keyCode == 32) { // 32 = spacebar
								ball.applyCentralImpulse(ballForce); // Apply force to the ball
							} else if (evt.keyCode == 37) { // 37 = left arrow
								shootArrowYAngle += (shootArrowYAngle + shootAngleStep < shootMaxYAngle) ? shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 38) { // 38 = up arrow
								shootArrowXAngle += (shootArrowXAngle + shootAngleStep < shootMaxXAngle) ? shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 39) { // 39 = right arrow
								shootArrowYAngle += (shootArrowYAngle - shootAngleStep > shootMinYAngle) ? - shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 40) { // 40 = down arrow
								shootArrowXAngle += (shootArrowXAngle - shootAngleStep > shootMinXAngle) ? - shootAngleStep : 0;
								recomputeShootForces();
							}
					};

					//document.addEventListener('keypress', handleKeyPress);
					document.addEventListener('keydown', handleKeyPress);
					//document.addEventListener('keydown', function(evt) {console.log(evt.keyCode)});
			}

			function animate() {
			    requestAnimationFrame( animate );

					// Simulate physics
					scene.simulate();

			    renderer.render( scene, camera );

					update();

					stats.update();
			}

			function update() {
					tick++;

					//controls.update();
					computeJoints();
					updateJoints();
			}

			function recomputeShootForces() {
					// rotate the shootArrow
					shootArrow.rotation.set(-math.pi/2,0,0,'XYZ');
					shootArrow.rotateZ(shootArrowYAngle);
					shootArrow.rotateX(shootArrowXAngle);

					// compute the forces
					ballForce.setX(math.cos(shootArrowXAngle) * math.sin(-shootArrowYAngle) * ballTotalForce);
					ballForce.setY(math.sin(shootArrowXAngle) * ballTotalForce);
					ballForce.setZ(-1 * math.cos(shootArrowXAngle) * math.cos(shootArrowYAngle) * ballTotalForce);
			}

			function computeJoints() {
					// target position as ball position
					parser.eval(
						`rd = [` + ball.position.x + ',' + ball.position.y + ',' + ball.position.z + `]`
					);
					// UPDATE q vector with new angle values
					// Cartesian error
					parser.eval(`cerr = (rd - f(q[1], q[2], q[3], q[4]))`)
					// Take gradient error
					parser.eval(`qerr = transpose(J(q[1], q[2], q[3], q[4])) * cerr`);

					var cerr = parser.get('cerr');
					var qerr = parser.get('qerr');

					// Limit joint displacements
					//for (var i=0; i<n_joints; i++) {
					//	if (math.abs(qerr.get([i])) > maxDisp) {
					//		deltaT[i] *= 1.01;
					//	} else if (math.abs(qerr.get([i])) < minDisp){
					//		deltaT[i] /= 1.01;
					//	}
					//}

					parser.eval(`q = q + [`+ deltaT.toString() +`] .* transpose(qerr)`);
					q = parser.get('q');
					//console.log('q    ' + parser.eval(`q`).toString());
					//console.log('f    ' + parser.eval(`f(q[1], q[2], q[3], q[4])`).toString());
					//console.log('cerr ' + cerr.toString());
					//console.log('qerr ' + qerr.toString());
					//console.log('delT ' + deltaT.toString());
					//console.log('d*qe ' + parser.eval(`[`+ deltaT.toString() +`] .* qerr`));
					//console.log('q    ' + q.toString());
					//console.log(parser.eval(`J(q[1], q[2], q[3], q[4])`));
			}

			function updateJoints() {
				var M = new THREE.Matrix4();
				for (var i=0; i<n_joints; i++) {

					tick ++;

					var Inv = new THREE.Matrix4().getInverse(joints[i].matrix);

					// Bring joint in the correct 0
					var S = new THREE.Matrix4();
					S.multiply(new THREE.Matrix4().makeTranslation(length[i]/2, 0, 0));
					S.multiply(new THREE.Matrix4().makeRotationZ(-math.pi/2));
					if (i>0)
						M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tx(dh[i-1][0], dh[i-1][1])).toArray())));//dh[i][2])).toArray())));
					M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tz(q.get([i]), dh[i][2])).toArray())));//dh[i][2])).toArray())));
					console.log(q.get([i]));
					var T = ((new THREE.Matrix4().multiply(M)).multiply(S)).multiply(Inv);




					joints[i].applyMatrix(T);
					//console.log(arrowHelperX[i]);
					/*
					* Frame origins
					*/
					//dirX[i].transformDirection(M[i]);
					//dirY[i].transformDirection(M[i]);
					//dirZ[i].transformDirection(M[i]);
					//origin[i].setFromMatrixColumn(M[i], 3);
					//var SX = new THREE.Matrix4();
					//var SY = new THREE.Matrix4();
					//var SZ = new THREE.Matrix4();
					//S.multiply(new THREE.Matrix4().makeTranslation(length[i]/2, 0, 0));
					//S.multiply(new THREE.Matrix4().makeRotationZ(-math.pi/2));

					//var Mx = new THREE.Matrix4().copy(arrowHelperX[i].matrix);
					//var My = new THREE.Matrix4().copy(arrowHelperY[i].matrix);
					//var Mz = new THREE.Matrix4().copy(arrowHelperZ[i].matrix);

					//arrowHelperX[i].applyMatrix(new THREE.Matrix4().extractRotation(Mx.transpose())); //new THREE.Matrix4().getInverse(arrowHelperX[i].matrix);
					//arrowHelperY[i].applyMatrix(new THREE.Matrix4().extractRotation(My.transpose())); //new THREE.Matrix4().getInverse(arrowHelperY[i].matrix);
					//arrowHelperZ[i].applyMatrix(new THREE.Matrix4().extractRotation(Mz.transpose())); //new THREE.Matrix4().getInverse(arrowHelperZ[i].matrix);
					//var TX = (new THREE.Matrix4().multiply(M)).multiply(InvX);
					//var TY = (new THREE.Matrix4().multiply(M)).multiply(InvY);
					//var TZ = (new THREE.Matrix4().multiply(M)).multiply(InvZ);
					//console.log(InvX.elements);
					//console.log(Mx.elements);
					//console.log(arrowHelperX[i].matrix.elements);

					//console.log(arrowHelperY[i].matrix.elements);
					//console.log(arrowHelperZ[i].matrix.elements);
					//arrowHelperX[i].setDirection(new THREE.Vector3(1, 0, 0));
					//arrowHelperX[i].applyMatrix(InvX);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//arrowHelperX[i].applyMatrix(M);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//arrowHelperY[i].applyMatrix(M);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//arrowHelperZ[i].applyMatrix(M);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//console.log(i);
					//console.log(M.elements);
					//console.log(arrowHelperX[i].rotation);

					//arrowHelperY[i].applyMatrix(TY);// = new THREE.ArrowHelper( dirY[i], origin[i], arrlength, hexY, headLength, widthLength );
					//arrowHelperZ[i].applyMatrix(TZ);// = new THREE.ArrowHelper( dirZ[i], origin[i], arrlength, hexZ, headLength, widthLength );

				}
			}

		</script>
	</body>
</html>
