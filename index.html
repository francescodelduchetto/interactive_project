<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100%; display: block }
		</style>
	</head>
	<body>
		<script src="js/math.js/math.min.js"></script>
		<script src="js/three.js/build/three.min.js"></script>
		<script src="js/OrbitControl.js"></script>
		<script src="js/Physijs/physi.js"></script>
		<script src="js/stats.min.js"></script>
		<script>

		// TODO:
		//	(1) palla con fisica (gravit√† con three js)
		//	(2) traiettoria robot che segue palla
		//	- textures - luci - mano - gioco - ambientazione

			'use strict';

			Physijs.scripts.worker = 'js/Physijs/physijs_worker.js';
			Physijs.scripts.ammo = '../ammo.js';

			var scene, camera, renderer, controls;
			var geometry, material, mesh;

			var parser;
			var stats;

			var ball;

			var tick = 0;

			//var M = {}; //new THREE.Matrix4();
			var q = {};
			var dh;
			var n_joints;
			var Tx, Tz;
			var J;

			var joints = {};
			var geometries = {};
			var materials = {};
			var frames = {};
			var length = {};

			var arrowHelperX = {};
			var arrowHelperY = {};
			var arrowHelperZ = {};
			var dirX = {};
			var dirY = {};
			var dirZ = {};
			var origin =  {};
			var arrlength = 100;
			var hexX = 0xff0000;
			var hexY = 0x00ff00;
			var hexZ = 0x0000ff;
			var headLength = 15;
			var widthLength = 15;

			var rd = [-1000, -1000,0];
			var deltaT = [0.0000001, 0.0000001, 0.0000001, 0.0000001] ;
			var q;
			var maxDisp = 300;
			var minDisp = 1;

			var ballInitPosition = [0, 0, 10000];
			var shootArrow, forceBar;
			var shootArrowXAngle = 0;
			var shootArrowYAngle = 0;
			var ballTotalForce = 50000;
			var ballForce = new THREE.Vector3(0,0,-ballTotalForce);
			var percForce = 1.0;


			init();
			animate();

			function init() {
					scene = new Physijs.Scene;

				 	parser = math.parser();


					parser.eval(
						`q = [0.01, 0, 0, 0]`//-pi/2, -0.7853981633974488, -0.7853981633974488]`
					);
					parser.eval(
						`dh(q1, q2, q3, q4) =
						[0,   500, 0, q1;
						 -pi/2, 0, 0, q2;
						 0, 500, 0, q3;
					   0, 200, 0,  q4]`
					);
					parser.eval(
						`Tz(th, d) =
						[cos(th), -sin(th), 0, 0;
						 sin(th),  cos(th), 0, 0;
					         0,        0, 1, d;
						       0,        0, 0, 1]`
					 );
					 parser.eval(
						 `Tx(al, a) =
						 [1,       0,        0, a;
						  0, cos(al), -sin(al), 0;
							0, sin(al),  cos(al), 0;
							0,       0,        0, 1]`
					 );
					 parser.eval(
						 `J(q1, q2, q3, q4) =
						 [ 200*sin(q1 + q2)*sin(q3)*sin(q4) - 500*sin(q1 + q2)*cos(q3) - 200*sin(q1 + q2)*cos(q3)*cos(q4) - 500*sin(q1), 200*sin(q1 + q2)*sin(q3)*sin(q4) - 200*sin(q1 + q2)*cos(q3)*cos(q4) - 500*sin(q1 + q2)*cos(q3), - 500*cos(q1 + q2)*sin(q3) - 200*cos(q1 + q2)*cos(q3)*sin(q4) - 200*cos(q1 + q2)*cos(q4)*sin(q3), - 200*cos(q1 + q2)*cos(q3)*sin(q4) - 200*cos(q1 + q2)*cos(q4)*sin(q3);
						   500*cos(q1) + 500*cos(q1 + q2)*cos(q3) + 200*cos(q1 + q2)*cos(q3)*cos(q4) - 200*cos(q1 + q2)*sin(q3)*sin(q4), 500*cos(q1 + q2)*cos(q3) + 200*cos(q1 + q2)*cos(q3)*cos(q4) - 200*cos(q1 + q2)*sin(q3)*sin(q4), - 500*sin(q1 + q2)*sin(q3) - 200*sin(q1 + q2)*cos(q3)*sin(q4) - 200*sin(q1 + q2)*cos(q4)*sin(q3), - 200*sin(q1 + q2)*cos(q3)*sin(q4) - 200*sin(q1 + q2)*cos(q4)*sin(q3);
						                                                                                                              0,                                                                                              0,                                                                 - 200*cos(q3 + q4) - 500*cos(q3),                                                     -200*cos(q3 + q4)]`
		 			);
					 parser.eval(
						 `f(q1, q2, q3, q4) =
						 [500*cos(q1) + 500*cos(q1 + q2)*cos(q3) + 200*cos(q1 + q2)*cos(q3)*cos(q4) - 200*cos(q1 + q2)*sin(q3)*sin(q4),
 						  500*sin(q1) + 500*sin(q1 + q2)*cos(q3) + 200*sin(q1 + q2)*cos(q3)*cos(q4) - 200*sin(q1 + q2)*sin(q3)*sin(q4),
                                                                             							- 200*sin(q3 + q4) - 500*sin(q3)]`
					 );

					var dhf = parser.get('dh');
					Tz = parser.get('Tz');
					Tx = parser.get('Tx');
					J  = parser.get('J');

					dh = dhf(0, 0, 0, 0).toArray();
					n_joints = dh.length;
					console.log('N joints:' + n_joints);

					var robot_arm = new THREE.Group();

					// Initialize q vector to initial configuration
					for (var i=0; i<n_joints; i++)
						q[i] = 0;

					/*
					 * Frame zero
					 */
					scene.add( new THREE.ArrowHelper( new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( 0, 0, 0 ), 200, hexX, headLength, widthLength ) );
					scene.add( new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 0 ), 200, hexY, headLength, widthLength ) );
					scene.add( new THREE.ArrowHelper( new THREE.Vector3( 0, 0, 1 ), new THREE.Vector3( 0, 0, 0 ), 200, hexZ, headLength, widthLength ) );

					//console.log(M.elements);

					// Create the robot arm according to the DH table
					var T = new THREE.Matrix4();
					for (var i=0; i<n_joints; i++) {
						length[i] = dh[i][1];

						geometries[i] = new THREE.CylinderGeometry( 20, 20, length[i], 16 );
						materials[i] = new THREE.MeshNormalMaterial( {wireframe: true } );

						joints[i] = new THREE.Mesh( geometries[i], materials[i] );

						robot_arm.add( joints[i] );

						/*
						 * Frame origins
						 */
						dirX[i]   = new THREE.Vector3( 1, 0, 0 );
						dirY[i]   = new THREE.Vector3( 0, 1, 0 );
						dirZ[i]   = new THREE.Vector3( 0, 0, 1 );
						origin[i] = new THREE.Vector3( 0, 0, 0 );

						arrowHelperX[i] = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
						arrowHelperY[i] = new THREE.ArrowHelper( dirY[i], origin[i], arrlength, hexY, headLength, widthLength );
						arrowHelperZ[i] = new THREE.ArrowHelper( dirZ[i], origin[i], arrlength, hexZ, headLength, widthLength );
						scene.add( arrowHelperX[i] );
						scene.add( arrowHelperY[i] );
						scene.add( arrowHelperZ[i] );
					}

					scene.add( robot_arm );

					// BALL
					ball = new Physijs.SphereMesh(
						new THREE.SphereGeometry( 50, 32, 32 ),
						new Physijs.createMaterial(
							new THREE.MeshNormalMaterial(),
							1, // friction
							1  // restitution
						),
						10 // mass
					);
					ball.translateZ(ballInitPosition[2]);

					scene.add(ball);


					// PLANE
					var plane = new Physijs.PlaneMesh(
						new THREE.PlaneGeometry( 400, 400, 32 ),
						new Physijs.createMaterial(
							new THREE.MeshNormalMaterial(),
							1, // friction
							0.3  // restitution
						),
						0
					);
					plane.translateY(-1);
					plane.rotateX(-math.pi/2);

					scene.add(plane);

					// GRAVITY
					scene.setGravity(new THREE.Vector3( 0, -1000, 0 ));

					// SHOOT ARROW
					var arrowShape = new THREE.Shape();
					arrowShape.moveTo(  -50, 0 );
					arrowShape.lineTo(  -100, 150 );
					arrowShape.lineTo( -200, 150 );
					arrowShape.lineTo(  0, 300 );
					arrowShape.lineTo(  200, 150 );
					arrowShape.lineTo(  100, 150 );
					arrowShape.lineTo(  50, 0 );
					arrowShape.lineTo(  -100, 0 );
					var arrowGeometry = new THREE.ShapeGeometry(arrowShape);
					shootArrow = new THREE.Mesh(arrowGeometry, new THREE.MeshNormalMaterial( { } ));

					shootArrow.translateZ(ballInitPosition[2] - 50);
					shootArrow.rotateX(-math.pi/2);
					shootArrow.rotateY(0);

          scene.add(shootArrow);

					// FORCE BAR
					var barShape = new THREE.Shape();
					barShape.moveTo(0, 0);
					barShape.lineTo(0, 200);
					barShape.lineTo(20, 200);
					barShape.lineTo(20, 0);
					//barShape.lineTo(0, 0);
					var barGeometry = new THREE.ShapeGeometry(barShape);
					forceBar = new THREE.Mesh(barGeometry, new THREE.MeshNormalMaterial());
					forceBar.position.x = 200;
					forceBar.position.z = ballInitPosition[2];

					scene.add(forceBar);

					// CAMERA
			    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 20000 );
			    //camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2,  window.innerHeight / 2, window.innerHeight / -2, 1, 20000 );
			    //camera.position.z = ballInitPosition[2];
			    camera.position.z = ballInitPosition[2] + 1000;
			    //camera.position.x = 1000;
			    camera.position.y = 700;
					//camera.lookAt(new THREE.Vector3(ballInitPosition[0], ballInitPosition[1], ballInitPosition[2]));
					camera.lookAt(new THREE.Vector3(0,0,0));

					// RENDERER
			    renderer = new THREE.WebGLRenderer({ antialias: true });
					renderer.setSize( window.innerWidth, window.innerHeight);
					renderer.shadowMap.enabled = true;
					renderer.shadowMapSoft = true

					// To move the scene according to mouse events
				//	controls = new THREE.OrbitControls( camera, renderer.domElement );
					//controls.enabled = false;

			    document.body.appendChild( renderer.domElement );

					stats = new Stats();
					document.body.appendChild( stats.dom );

					// Trigger for user events
					initEventHandling();
			}

			function initEventHandling() {
					var handleKeyPress = function(evt) {
							var shootAngleStep = math.pi/48, shootForceStep = 0.1;
							var shootMaxXAngle = math.pi/2, shootMinXAngle = 0;
							var shootMaxYAngle = math.pi/6, shootMinYAngle = -math.pi/3;
							if (evt.keyCode == 32) { // 32 = spacebar
								ball.applyCentralImpulse(ballForce); // Apply force to the ball
							} else if (evt.keyCode == 37) { // 37 = left arrow
								shootArrowYAngle += (shootArrowYAngle + shootAngleStep < shootMaxYAngle) ? shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 38) { // 38 = up arrow
								shootArrowXAngle += (shootArrowXAngle + shootAngleStep < shootMaxXAngle) ? shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 39) { // 39 = right arrow
								shootArrowYAngle += (shootArrowYAngle - shootAngleStep > shootMinYAngle) ? - shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 40) { // 40 = down arrow
								shootArrowXAngle += (shootArrowXAngle - shootAngleStep > shootMinXAngle) ? - shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 107) { // 107 = +
								percForce += shootForceStep;
								recomputeShootForces();
							} else if (evt.keyCode == 109) { // 109 = -
								percForce -= shootForceStep;
								recomputeShootForces();
							}
					};

					//document.addEventListener('keypress', handleKeyPress);
					document.addEventListener('keydown', handleKeyPress);
					//document.addEventListener('keydown', function(evt) {console.log(evt.keyCode)});
			}

			function animate() {
			    requestAnimationFrame( animate );

					// Simulate physics
					scene.simulate();

			    renderer.render( scene, camera );

					update();

					stats.update();
			}

			function update() {
					tick++;
					//controls.update();
					computeJoints();
					updateJoints();
			}

			function recomputeShootForces() {
					// rotate the shootArrow
					shootArrow.rotation.set(-math.pi/2,0,0,'XYZ');
					shootArrow.rotateZ(shootArrowYAngle);
					shootArrow.rotateX(shootArrowXAngle);

					// scale force bar
					forceBar.scale.setY(percForce);

					// compute the forces
					ballForce.setX(math.cos(shootArrowXAngle) * math.sin(-shootArrowYAngle) * ballTotalForce * percForce);
					ballForce.setY(math.sin(shootArrowXAngle) * ballTotalForce * percForce);
					ballForce.setZ(-1 * math.cos(shootArrowXAngle) * math.cos(shootArrowYAngle) * ballTotalForce * percForce);
			}

			function computeJoints() {
					// target position as ball position
					parser.eval(
						`rd = [` + ball.position.x + ',' + ball.position.y + ',' + ball.position.z + `]`
					);
					// UPDATE q vector with new angle values
					// Cartesian error
					parser.eval(`cerr = (rd - f(q[1], q[2], q[3], q[4]))`)
					// Take gradient error
					parser.eval(`qerr = transpose(J(q[1], q[2], q[3], q[4])) * cerr`);

					var cerr = parser.get('cerr');
					var qerr = parser.get('qerr');

					// Limit joint displacements
					//for (var i=0; i<n_joints; i++) {
					//	if (math.abs(qerr.get([i])) > maxDisp) {
					//		deltaT[i] *= 1.01;
					//	} else if (math.abs(qerr.get([i])) < minDisp){
					//		deltaT[i] /= 1.01;
					//	}
					//}

					parser.eval(`q = q + [`+ deltaT.toString() +`] .* transpose(qerr)`);
					q = parser.get('q');
					//console.log('q    ' + parser.eval(`q`).toString());
					//console.log('f    ' + parser.eval(`f(q[1], q[2], q[3], q[4])`).toString());
					//console.log('cerr ' + cerr.toString());
					//console.log('qerr ' + qerr.toString());
					//console.log('delT ' + deltaT.toString());
					//console.log('d*qe ' + parser.eval(`[`+ deltaT.toString() +`] .* qerr`));
					//console.log('q    ' + q.toString());
					//console.log(parser.eval(`J(q[1], q[2], q[3], q[4])`));
			}

			function updateJoints() {
				var M = new THREE.Matrix4();
				for (var i=0; i<n_joints; i++) {

					tick ++;

					var Inv = new THREE.Matrix4().getInverse(joints[i].matrix);

					// Bring joint in the correct 0
					var S = new THREE.Matrix4();
					S.multiply(new THREE.Matrix4().makeTranslation(length[i]/2, 0, 0));
					S.multiply(new THREE.Matrix4().makeRotationZ(-math.pi/2));
					if (i>0)
						M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tx(dh[i-1][0], dh[i-1][1])).toArray())));//dh[i][2])).toArray())));
					M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tz(q.get([i]), dh[i][2])).toArray())));//dh[i][2])).toArray())));
					var T = ((new THREE.Matrix4().multiply(M)).multiply(S)).multiply(Inv);




					joints[i].applyMatrix(T);
					//console.log(arrowHelperX[i]);
					/*
					* Frame origins
					*/
					//dirX[i].transformDirection(M[i]);
					//dirY[i].transformDirection(M[i]);
					//dirZ[i].transformDirection(M[i]);
					//origin[i].setFromMatrixColumn(M[i], 3);
					//var SX = new THREE.Matrix4();
					//var SY = new THREE.Matrix4();
					//var SZ = new THREE.Matrix4();
					//S.multiply(new THREE.Matrix4().makeTranslation(length[i]/2, 0, 0));
					//S.multiply(new THREE.Matrix4().makeRotationZ(-math.pi/2));

					//var Mx = new THREE.Matrix4().copy(arrowHelperX[i].matrix);
					//var My = new THREE.Matrix4().copy(arrowHelperY[i].matrix);
					//var Mz = new THREE.Matrix4().copy(arrowHelperZ[i].matrix);

					//arrowHelperX[i].applyMatrix(new THREE.Matrix4().extractRotation(Mx.transpose())); //new THREE.Matrix4().getInverse(arrowHelperX[i].matrix);
					//arrowHelperY[i].applyMatrix(new THREE.Matrix4().extractRotation(My.transpose())); //new THREE.Matrix4().getInverse(arrowHelperY[i].matrix);
					//arrowHelperZ[i].applyMatrix(new THREE.Matrix4().extractRotation(Mz.transpose())); //new THREE.Matrix4().getInverse(arrowHelperZ[i].matrix);
					//var TX = (new THREE.Matrix4().multiply(M)).multiply(InvX);
					//var TY = (new THREE.Matrix4().multiply(M)).multiply(InvY);
					//var TZ = (new THREE.Matrix4().multiply(M)).multiply(InvZ);
					//console.log(InvX.elements);
					//console.log(Mx.elements);
					//console.log(arrowHelperX[i].matrix.elements);

					//console.log(arrowHelperY[i].matrix.elements);
					//console.log(arrowHelperZ[i].matrix.elements);
					//arrowHelperX[i].setDirection(new THREE.Vector3(1, 0, 0));
					//arrowHelperX[i].applyMatrix(InvX);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//arrowHelperX[i].applyMatrix(M);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//arrowHelperY[i].applyMatrix(M);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//arrowHelperZ[i].applyMatrix(M);// = new THREE.ArrowHelper( dirX[i], origin[i], arrlength, hexX, headLength, widthLength );
					//console.log(i);
					//console.log(M.elements);
					//console.log(arrowHelperX[i].rotation);

					//arrowHelperY[i].applyMatrix(TY);// = new THREE.ArrowHelper( dirY[i], origin[i], arrlength, hexY, headLength, widthLength );
					//arrowHelperZ[i].applyMatrix(TZ);// = new THREE.ArrowHelper( dirZ[i], origin[i], arrlength, hexZ, headLength, widthLength );

				}
			}

		</script>
	</body>
</html>
