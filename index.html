<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100%; display: block }
		</style>
	</head>
	<body>
		<script src="js/math.js/math.min.js"></script>
		<script src="js/three.js/build/three.min.js"></script>
		<script src="js/OrbitControl.js"></script>
		<script src="js/Physijs/physi.js"></script>
		<script src="js/cloth.js/Cloth.js"></script>
		<script src="js/stats.min.js"></script>
		<script>

		// TODO:
		//	(1) palla con fisica (gravitÃ  con three js)
		//	(2) traiettoria robot che segue palla
		//	- textures - luci - mano - gioco - ambientazione

			'use strict';

			Physijs.scripts.worker = 'js/Physijs/physijs_worker.js';
			Physijs.scripts.ammo = '../ammo.js';

			var scene, camera, renderer, controls;
			var init, animate;

			var parser;
			var stats;

			var net, netGeometry, netGeometry1;
			var segs = 10;
			var pins = [];
			var cloth, cloth1;
			//var M = {}; //new THREE.Matrix4();
			var q = {}, dh, n_joints, Txz, J;

			var ground, ground_material, ground_geometry, ball, ballSize = 170,
					ballGeometry, ballMaterial;
			var font, textShape, textMaterial, textMesh = new THREE.Mesh(), text = "0 - 0";
			var joints = {};
			var geometries = {};
			var materials = {};
			var length = {};

			var rd = [-1000, -1000,0];
			var deltaTDef =  [0.0000001, 0.0000001, 0.0000001, 0.0000001], deltaT = deltaTDef;
			var maxDisp = 300;
			var minDisp = 1;

			var ballInitPosition = [0, 100, 10000];
			var shootArrow, arrowShape, arrowGeometry, forceBar, barShape, barGeometry;
			var shootArrowXAngle = 0;
			var shootArrowYAngle = 0;
			var ballTotalForce = 50000;
			var ballForce = new THREE.Vector3(0,0,-ballTotalForce);
			var percForce = 1.0;


			var GameState = {
				READY : "ready",  // waiting for user shooting
				SHOOT : "shoot",  // ball travelling to the goal
				GOAL : "goal",   // user scored, ball inside the dof_enable
				SAVED : "saved",  // ball bounced against the robot
				MISSED : "missed" // ball is outside the net and it has not been saved
			};
			var game = {
				stateInternal: undefined,
				lastChangeTimeInternal: Date.now(),
				pointsRobot: 0,
				pointsUser: 0,
				stateListener: function(new_state, old_state) {},
				set state(new_state) {
					var old_state = this.stateInternal;
					this.stateInternal = new_state;
					this.stateListener(new_state, old_state);
					this.lastChangeTimeInternal = Date.now();
				},
				get state() {
					return this.stateInternal;
				},
				get timeSinceChange() {
					return Date.now() - this.lastChangeTimeInternal;
				},
				registerStateChangeListener: function(listener) {
					this.stateListener = listener;
				},
			};

			game.registerStateChangeListener(function(n, o) {
				console.log("GAME_STATE_CHANGE: " + o + " -> " + n);
				if (n == GameState.GOAL || n == GameState.MISSED) {
					++game.pointsUser;
				} else if (n == GameState.SAVED){
					++game.pointsRobot;
				}
				createText();
			});

			const RESET_TIME = 5000; // [ms]

			init = function () {
					// RENDERER
					renderer = new THREE.WebGLRenderer({ antialias: true });
					renderer.setSize( window.innerWidth, window.innerHeight);
					renderer.shadowMap.enabled = true;
					renderer.shadowMapSoft = true

					// SCENE
					scene = new Physijs.Scene;
					// GRAVITY
					scene.setGravity(new THREE.Vector3( 0, -1000, 0 ));
					scene.addEventListener(
						'update',
						function() {
							// Simulate physics
							scene.simulate();

							stats.update();
						}
					)

					// CAMERA
			    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 20000 );
			    //camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2,  window.innerHeight / 2, window.innerHeight / -2, 1, 20000 );
			    //camera.position.z = ballInitPosition[2];
			    camera.position.z = ballInitPosition[2] + 1000;
			    //camera.position.x = 1000;
			    camera.position.y = 700;
					//camera.lookAt(new THREE.Vector3(ballInitPosition[0], ballInitPosition[1], ballInitPosition[2]));
					camera.lookAt(new THREE.Vector3(0,0,0));

					// MATHJS PARSER
				 	parser = math.parser();


					parser.eval(
						`q = [pi/2, 0, 0, 0]`//-pi/2, -0.7853981633974488, -0.7853981633974488]`
					);
					parser.eval(
						`l = [1500, 0, 1500, 300]`
					)
					parser.eval(
						`dh(q1, q2, q3, q4) =
						[    0, l[1], 0, q1;
						 -pi/2, l[2], 0, q2;
						     0, l[3], 0, q3;
					       0, l[4], 0, q4]`
					);
					 parser.eval(
						 `Txz(al, a, d, th) =
						 [         cos(th),        -sin(th),        0,          a;
						   cos(al)*sin(th), cos(al)*cos(th), -sin(al), -d*sin(al);
						   sin(al)*sin(th), sin(al)*cos(th),  cos(al),  d*cos(al);
						                 0,               0,        0,          1]`
					 );
					 parser.eval(
						 `J(q1, q2, q3, q4) =
						 [ l[4]*sin(q1 + q2)*sin(q3)*sin(q4) - l[1]*sin(q1) - l[3]*sin(q1 + q2)*cos(q3) - l[4]*sin(q1 + q2)*cos(q3)*cos(q4) - l[2]*sin(q1 + q2), -sin(q1 + q2)*(l[2] + l[4]*cos(q3 + q4) + l[3]*cos(q3)), -cos(q1 + q2)*(l[4]*sin(q3 + q4) + l[3]*sin(q3)), -l[4]*cos(q1 + q2)*sin(q3 + q4);
					 	   l[2]*cos(q1 + q2) + l[1]*cos(q1) + l[3]*cos(q1 + q2)*cos(q3) + l[4]*cos(q1 + q2)*cos(q3)*cos(q4) - l[4]*cos(q1 + q2)*sin(q3)*sin(q4),  cos(q1 + q2)*(l[2] + l[4]*cos(q3 + q4) + l[3]*cos(q3)), -sin(q1 + q2)*(l[4]*sin(q3 + q4) + l[3]*sin(q3)), -l[4]*sin(q1 + q2)*sin(q3 + q4);
				 		    	                                                                                                                      					0,                                               			   0,               - l[4]*cos(q3 + q4) - l[3]*cos(q3),              -l[4]*cos(q3 + q4)]`
		 			);
					 parser.eval(
						 `f(q1, q2, q3, q4) =
						 [l[2]*cos(q1 + q2) + l[1]*cos(q1) + l[3]*cos(q1 + q2)*cos(q3) + l[4]*cos(q1 + q2)*cos(q3)*cos(q4) - l[4]*cos(q1 + q2)*sin(q3)*sin(q4),
 						  l[2]*sin(q1 + q2) + l[1]*sin(q1) + l[3]*sin(q1 + q2)*cos(q3) + l[4]*sin(q1 + q2)*cos(q3)*cos(q4) - l[4]*sin(q1 + q2)*sin(q3)*sin(q4),
                                                                                             										- l[4]*sin(q3 + q4) - l[3]*sin(q3)]`
					 );

					var dhf = parser.get('dh');
					Txz = parser.get('Txz');
					J  = parser.get('J');

					dh = dhf(0, 0, 0, 0).toArray();
					n_joints = dh.length;
					console.log('N joints:' + n_joints);

					//TextureLoader
						loader = new THREE.TextureLoader();
					// Initialize q vector to initial configuration
					for (var i=0; i<n_joints; i++)
						q[i] = 0;

					//var robot_arm = new THREE.Group();


					// NET
					cloth = new Cloth(2000, 2000);
					cloth1 = new Cloth(2000, 2000);
					cloth.wind = true;
					cloth1.wind = true;
					netGeometry1 = new THREE.ParametricGeometry(cloth1.clothFunction, segs, segs);
					cloth1.setGeometry(netGeometry1);
					var net1 = new THREE.Mesh(netGeometry1, new THREE.MeshNormalMaterial());
					//scene.add(net1);
					// Initialize pins
					var pins = [];
					for (var i=0; i<=segs; i++) {
						pins.push(i);
						pins.push(i*(segs+1));
						pins.push((i+1)*(segs+1)-1);
						pins.push((segs+1)*(segs+1)-1-i);
					}
					cloth.pins = pins;
					var pins = [];
					for (var i=0; i<segs; i++) {
						pins.push(i);
						pins.push(i*11);
						pins.push((i+1)*11-1);
						pins.push(120-i);
					}
					cloth1.pins = pins;

					var loaderNet = new THREE.TextureLoader();
					var clothTexture = loaderNet.load( 'images/netthick.png' );
					clothTexture.wrapS = clothTexture.wrapT = THREE.RepeatWrapping;

					//clothTexture.repeat.set( 1, 1 );
				  clothTexture.anisotropy = 100;

					var clothMaterial = new THREE.MeshPhongMaterial( {
						specular: 0x030303,
						map: clothTexture,
						side: THREE.DoubleSide,
						alphaTest: 0.5
					} );

					// net geometry
					netGeometry =  new THREE.ParametricGeometry( cloth.clothFunction, segs, segs );
					cloth.setGeometry(netGeometry);

					net = new THREE.Mesh( netGeometry, clothMaterial );
					net.position.set( 0, 0, 0 );
					net.castShadow = true;
					scene.add( net );
					net.customDepthMaterial = new THREE.MeshBasicMaterial( { map: clothTexture, transparent: true } ) ;


					// Create the robot arm according to the DH table
					var T = new THREE.Matrix4();
					for (var i=0; i<n_joints; i++) {
						length[i] = dh[i][1];

						if (i == n_joints-1) {
							geometries[i] = new THREE.CylinderGeometry( length[i], length[i], 50, 16 );
						} else {
							geometries[i] = new THREE.CylinderGeometry( 50, 30, length[i], 16 );
						}
						materials[i] = new Physijs.createMaterial(
														new THREE.MeshNormalMaterial(),
														1, // friction
														1  // restitution
													);

						//joints[i] = new Physijs.CylinderMesh( geometries[i], materials[i],0);
						joints[i] = new Physijs.CylinderMesh( geometries[i], materials[i], 0);
						scene.add( joints[i] );

						joints[i].addEventListener('collision', (function(object) {
							var n = i;
							return function() {console.log('joint' + n + ' collision')};
						})());

					}

					//scene.add( robot_arm );

					// BALL
					ballGeometry = new THREE.SphereGeometry( ballSize, 32, 32 );
					ballMaterial = new Physijs.createMaterial(
													new THREE.MeshNormalMaterial(),
													1, // friction
													1  // restitution
												);
					ball = new Physijs.SphereMesh(
						ballGeometry,
						ballMaterial,
						10 // mass
					);

					//ball.translateZ(ballInitPosition[2]);
					//ball.translateY(ballInitPosition[1]);

					//ball.setCcdMotionThreshold(0.1);
					//ball.setCcdSweptSphereRadius(25);

					scene.add(ball);
					cloth.setBall(ball);
					cloth1.setBall(ball);

					//GROUND
					var loader= new THREE.TextureLoader();
				  ground_material = Physijs.createMaterial(
						new THREE.MeshLambertMaterial({ map: loader.load( 'images/grass.png' ) }),
						.8, // high friction
						.3 // low restitution
					);
					ground_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
					ground_material.map.repeat.set( 10, 50 );

					ground_geometry = new THREE.PlaneGeometry(10000, 100000, 100);
					ground = new Physijs.PlaneMesh(	ground_geometry,	ground_material,	0 );
					ground.rotateX(-math.pi/2);
					ground.receiveShadow = true;
					ground.position.y=-1;
					scene.add(ground);

					//luce NECESSARIA per la texture
					var light = new THREE.DirectionalLight( 0xFFFFFF );
					light.position.set( 20, 40, -15 );
					light.target.position.copy( scene.position );
					light.castShadow = true;
					light.shadow.camera.left = -60;
					light.shadow.camera.top = -60;
					light.shadow.camera.right = 60;
					light.shadow.camera.bottom = 60;
					light.shadow.camera.near = 20;
					light.shadow.camera.far = 200;
					light.shadow.bias = -.0001;
					light.shadow.mapSize.width = light.shadow.mapSize.height = 2048;
					//light.shadowDarkness = .7;
					scene.add( light );

					// SHOOT ARROW
					arrowShape = new THREE.Shape();
					arrowShape.moveTo( -50, 0 );
					arrowShape.lineTo( -100, 150 );
					arrowShape.lineTo(-200, 150 );
					arrowShape.lineTo( 0, 300 );
					arrowShape.lineTo( 200, 150 );
					arrowShape.lineTo( 100, 150 );
					arrowShape.lineTo( 50, 0 );
					arrowShape.lineTo( -50, 0 );
					arrowGeometry = new THREE.ShapeGeometry(arrowShape);
					shootArrow = new THREE.Mesh(arrowGeometry, new THREE.MeshNormalMaterial( { } ));

					//shootArrow.translateZ(ballInitPosition[2] - 50);
					//shootArrow.rotateX(-math.pi/2);
					//shootArrow.rotateY(0);

          scene.add(shootArrow);

					// FORCE BAR
					barShape = new THREE.Shape();
					barShape.moveTo(0, 0);
					barShape.lineTo(0, 200);
					barShape.lineTo(20, 200);
					barShape.lineTo(20, 0);
					barShape.lineTo(0, 0);
					barGeometry = new THREE.ShapeGeometry(barShape);
					forceBar = new THREE.Mesh(barGeometry, new THREE.MeshNormalMaterial());
					//forceBar.position.x = 200;
					//forceBar.position.z = ballInitPosition[2];

					scene.add(forceBar);

					// To move the scene according to mouse events
					controls = new THREE.OrbitControls( camera, renderer.domElement );
					//controls.enabled = false;

			    document.body.appendChild( renderer.domElement );

					stats = new Stats();
					document.body.appendChild( stats.dom );

					// Trigger for user events
					initEventHandling();

					game.state = GameState.READY;

					requestAnimationFrame( animate );

					scene.simulate();

					setUpReady();
			}

			function createText() {
				text = game.pointsUser + " - " + game.pointsRobot;
				// Text points count
				var loader = new THREE.FontLoader();

				scene.remove(textMesh);
				loader.load('js/three.js/examples/fonts/gentilis_bold.typeface.json', function ( response ) {
					textShape = new THREE.TextGeometry(text, {font: response,
						        size: 20, // font size
						        height: 1, // how much extrusion (how thick / deep are the letters)
						        curveSegments: 12,
						        bevelThickness: 1,
						        bevelSize: 1,
						        bevelEnabled: true}
									);
					textShape.computeBoundingBox();
					textMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
					textMesh = new THREE.Mesh(textShape, textMaterial);
					//textMesh.translateY(4000);
					textMesh.translateZ(ballInitPosition[2] - 3000);
					textMesh.translateX(1000);
					textMesh.scale.set(20, 20, 20);
					scene.add(textMesh);
				} );
			}

			function setUpReady() {
				// reset ball
				ball.setLinearVelocity(new THREE.Vector3(0, 0, 0));
				ball.setAngularVelocity(new THREE.Vector3(0, 0, 0));
				ball.position.z = ballInitPosition[2];
				ball.position.y = ballInitPosition[1];
				ball.position.x = ballInitPosition[0];
				ball.__dirtyPosition = true;
				ball.__dirtyRotation = true;

				// reset shootArrow
				shootArrow.position.z = (ballInitPosition[2] - 50);
				//shootArrow.rotateX(-math.pi/2)
				shootArrow.rotation.set(-math.pi/2,0,0,'XYZ');
				shootArrowYAngle = 0;
				shootArrowXAngle = 0;
				//shootArrow.rotateZ(shootArrowYAngle);
				//shootArrow.rotateX(shootArrowXAngle);

				// reset forceBar
				forceBar.position.x = 200;
				forceBar.position.z = ballInitPosition[2];
				percForce = 1.0;
				forceBar.scale.setY(percForce);

				recomputeShootForces();
			}

			function initEventHandling() {
					var handleKeyPress = function(evt) {
							var shootAngleStep = math.pi/48, shootForceStep = 0.1;
							var shootMaxXAngle = math.pi/2, shootMinXAngle = 0;
							var shootMaxYAngle = math.pi/6, shootMinYAngle = -math.pi/3;
							if (evt.keyCode == 32) { // 32 = spacebar
								//if (game_state == GameState.READY) {
									ball.applyCentralImpulse(ballForce); // Apply force to the ball
								//	game_state = GameState.SHOOT;
								//}
							} else if (evt.keyCode == 65) { // 37 = left arrow
								shootArrowYAngle += (shootArrowYAngle + shootAngleStep < shootMaxYAngle) ? shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 87) { // 38 = up arrow
								shootArrowXAngle += (shootArrowXAngle + shootAngleStep < shootMaxXAngle) ? shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 68) { // 39 = right arrow
								shootArrowYAngle += (shootArrowYAngle - shootAngleStep > shootMinYAngle) ? - shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 83) { // 40 = down arrow
								shootArrowXAngle += (shootArrowXAngle - shootAngleStep > shootMinXAngle) ? - shootAngleStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 107) { // 107 = +
								percForce += (percForce < 1) ? shootForceStep : 0;
								recomputeShootForces();
							} else if (evt.keyCode == 109) { // 109 = -
								percForce -= (percForce > 0.01) ? shootForceStep : 0;
								recomputeShootForces();
							}
					};

					//document.addEventListener('keypress', handleKeyPress);
					document.addEventListener('keydown', handleKeyPress);
					//document.addEventListener('keydown', function(evt) {console.log(evt.keyCode)});

					var handleCollision = function(obj) {
						console.log('ball collision');
					};

					ball.addEventListener('collision', handleCollision);

				}


			animate = function () {
				var time = Date.now();

				cloth.windStrength = Math.cos( time / 7000 ) * 20 + 40;
				cloth.windForce.set( Math.sin( time / 2000 ), Math.cos( time / 3000 ), Math.sin( time / 1000 ) ).normalize().multiplyScalar( cloth.windStrength );
				cloth1.windStrength = Math.cos( time / 70 ) * 50 + 140;
				cloth1.windForce.set( Math.sin( time / 2000 ), Math.cos( time / 3000 ), Math.sin( time / 1000 ) ).normalize().multiplyScalar( cloth1.windStrength );
				cloth.simulate( time );
				cloth1.simulate( time );

				var p = cloth.particles;
				var p1 = cloth1.particles;
				//console.log(p[37].position);
				for ( var i = 0; i < p.length; i ++ ) {
					netGeometry.vertices[ i ].copy( p[ i ].position );
				}
				for ( var i = 0; i < p1.length; i ++ ) {
					//console.log(p1[i].position);
					netGeometry1.vertices[ i ].copy( p1[ i ].position );
				}
				netGeometry.computeFaceNormals();
				netGeometry.computeVertexNormals();
				netGeometry.normalsNeedUpdate = true;
				netGeometry.verticesNeedUpdate = true;
				netGeometry1.computeFaceNormals();
				netGeometry1.computeVertexNormals();
				netGeometry1.normalsNeedUpdate = true;
				netGeometry1.verticesNeedUpdate = true;


			  requestAnimationFrame( animate );

				updateGameState();

				updateJoints();

				controls.update();

				renderer.render( scene, camera );
			}

			function updateGameState() {
				//console.log(ball.getLinearVelocity().z);
				if (game.state == GameState.READY && ball.getLinearVelocity().z < 0 && ball.position.z != ballInitPosition[2]) {
					game.state = GameState.SHOOT;
				} else if (game.state == GameState.SHOOT) {
					if (ball.getLinearVelocity().z > 0) {
						game.state = GameState.SAVED;
					} else if (ball.position.z < -200){
						game.state = GameState.MISSED;
					}
				}
				if (game.state != GameState.READY && game.timeSinceChange > RESET_TIME) {
					game.state = GameState.READY;
					setUpReady();
				}
				textMesh.lookAt(camera.position);
			}

			function recomputeShootForces() {
					// rotate the shootArrow
					shootArrow.rotation.set(-math.pi/2,0,0,'XYZ');
					shootArrow.rotateZ(shootArrowYAngle);
					shootArrow.rotateX(shootArrowXAngle);

					// scale force bar
					forceBar.scale.setY(percForce);

					// compute the forces
					ballForce.setX(math.cos(shootArrowXAngle) * math.sin(-shootArrowYAngle) * ballTotalForce * percForce);
					ballForce.setY(math.sin(shootArrowXAngle) * ballTotalForce * percForce);
					ballForce.setZ(-1 * math.cos(shootArrowXAngle) * math.cos(shootArrowYAngle) * ballTotalForce * percForce);
			}

			function computeJoints() {
					parser.eval(`sl = l[1]+l[2]+l[3]+l[4]`)
					var distance_limit = parser.get(`sl`);
					//&console.log(math.min(ball.position.y, distance_limit));
					var jointVelMax = 0.07;
					if (game.state == GameState.SHOOT) {
						if (ball.position.z < 1000) {
							jointVelMax = 0.07;
							parser.eval(
									`rd = [` + math.min(ball.position.x, distance_limit) + ',' + math.min(ball.position.y, distance_limit) + ',' + math.min(ball.position.z + 50, distance_limit)  + `]`
							);
						} else if (ball.position.z < 4000) {
							jointVelMax = 0.07;
							parser.eval(
									`rd = [` + math.min(ball.position.x, distance_limit)+ ',' + math.min(ball.position.y, distance_limit) + ',' + (-2000) + `]`
							);
						} else {
							jointVelMax = 0.05;
							parser.eval(
								`rd = [` + math.min(ball.position.x, distance_limit) + ',' + math.min(ball.position.y, distance_limit) + ',' + 0 + `]`
							);
						}
					} else {
						jointVelMax = 0.01;
						var d = 0;//1000 * shootArrow.rotation.z * -1;
					//	if (shootArrow.rotation.z > 0)
					//		d = -1000;
					//	if (shootArrow.rotation.z < 0)
					//		d = 500;
						parser.eval(
							`rd = [`+ d +`, l[1]+l[2]+l[3]+l[4] + 1000, 0]`
						);
					}
					parser.eval(
						`rd = [`+ 0 +`, l[1]+l[2]+l[3]+l[4] + 1000, 0]`
					);
					//console.log((parser.get(`rd`).toString()));
					// target position as ball position
					//if (ball.position.z > 4000) {
					//	parser.eval(
					//		`rd = [` + ball.position.x + ',' + ball.position.y + ',' + 0 + `]`
					//	);
					//	deltaT = deltaTDef;
					//} else if (ball.position.z < -1000) {
					//	parser.eval(
					//		//`rd = [` + camera.position.x + ',' + camera.position.y + ',' + 0 + `]`
					//		`rd = [0, 2000, 0]`
					//	);
					//	deltaT = deltaTDef;
					//} else if (ball.position.z > 1000) {
					//	parser.eval(
					//		`rd = [` + ball.position.x + ',' + ball.position.y + ',' + (-2000) + `]`
					//	);
					//	deltaT = deltaTDef;
					//	//parser.eval(
					//	//	`rd = [` + ball.position.x + ',' + ball.position.y + ',' + 0 + `]`
					//	//);
					//} else {
					//	//parser.eval(
					//	//	`rd = [` + ball.position.x + ',' + ball.position.y + ',' + 0 + `]`
					//	//);
					//	parser.eval(
					//		`rd = [` + ball.position.x + ',' + ball.position.y + ',' + ball.position.z + `]`
					//	);
					//	//for (var i=0; i<n_joints; i++) {
					//	//	deltaT[i] *= 1.02;
					//	//}
					//}
					//parser.eval(
					//	`rd = [0, 2000, 0]`
					//);

					// doesn't make the "hand" going inside the ground
					var rd = parser.get('rd');
					if (rd.get([1]) < length[n_joints - 1])
						parser.eval(`rd = [rd[1], `+ length[n_joints - 1] +`, rd[3]]`);

					// UPDATE q vector with new angle values
					// Cartesian error
					parser.eval(`cerr = (rd - f(q[1], q[2], q[3], q[4]))`)
					// Take gradient error
					parser.eval(`qerr = transpose(J(q[1], q[2], q[3], q[4])) * cerr`);

					//var cerr = parser.get('cerr');
					//var qerr = parser.get('qerr');

					// Limit joint displacements
					//for (var i=0; i<n_joints; i++) {
					//	if (math.abs(qerr.get([i])) > maxDisp) {
					//		deltaT[i] *= 1.01;
					//	} else if (math.abs(qerr.get([i])) < minDisp){
					//		deltaT[i] /= 1.01;
					//	}
					//}

					//parser.eval(`vel = [`+ deltaT.toString() +`] .* qerr`);
					parser.set(`vel`, []);
					for (var i=1; i<=n_joints; i++) {
						parser.eval(`vel[`+ i +`] = min(abs(`+ deltaT[i-1].toString() +` * qerr[`+ i +`]), `+ jointVelMax +`) * sign(qerr[`+ i +`])`);
					}

					//console.log(parser.get(`vel`));

					parser.eval(`q = q + vel`);
					q = parser.get('q');

					// limit joint 1
					if (q.get([0]) > math.pi)
						q.set([0], math.pi);
					else if (q.get([0]) < 0)
						q.set([0], 0);


					//console.log('q    ' + parser.eval(`q`).toString());
					//console.log('f    ' + parser.eval(`f(q[1], q[2], q[3], q[4])`).toString());
					//console.log('cerr ' + cerr.toString());
					//console.log('qerr ' + qerr.toString());
					//console.log('delT ' + deltaT.toString());
					//console.log('d*qe ' + parser.eval(`[`+ deltaT.toString() +`] .* qerr`));
					//console.log('q    ' + q.toString());
					//console.log(parser.eval(`J(q[1], q[2], q[3], q[4])`));
			}

			function updateJoints() {

				computeJoints();

				var M = new THREE.Matrix4();
				for (var i=0; i<n_joints; i++) {

					var Inv = new THREE.Matrix4().getInverse(joints[i].matrix);

					// Bring joint in the correct 0
					var S = new THREE.Matrix4();
					S.multiply(new THREE.Matrix4().makeTranslation(length[i]/2, 0, 0));
					S.multiply(new THREE.Matrix4().makeRotationZ(-math.pi/2));
					if (i == n_joints-1)
						S.multiply(new THREE.Matrix4().makeRotationZ(math.pi/2));

					//if (i>0)
					//	M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tx(dh[i-1][0], dh[i-1][1])).toArray())));//dh[i][2])).toArray())));
					//M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Tz(q.get([i]), dh[i][2])).toArray())));//dh[i][2])).toArray())));

					if (i>0)
						M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Txz(dh[i-1][0], dh[i-1][1], dh[i][2], q.get([i])).toArray()))));
					else
						M.multiply(new THREE.Matrix4().fromArray(math.flatten(math.transpose(Txz(0, 0, dh[i][2], q.get([i])).toArray()))));

					var T = ((new THREE.Matrix4().multiply(M)).multiply(S)).multiply(Inv);
					//console.log(T.elements);
					//console.log(q.get([i]));



					joints[i].applyMatrix(T);
					joints[i].__dirtyPosition = true;
					joints[i].__dirtyRotation = true;
					//console.log(joints[i]);
					//console.log(arrowHelperX[i]);

				}
			}
			window.onload = init;

		</script>
	</body>
</html>
